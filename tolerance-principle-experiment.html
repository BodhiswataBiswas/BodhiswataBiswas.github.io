<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tolerance Principle - Visual Rule Learning Experiment</title>

    <!--
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║                    TOLERANCE PRINCIPLE EXPERIMENT                             ║
    ║                    Visual Rule Learning with jsPsych 7.x                      ║
    ╠══════════════════════════════════════════════════════════════════════════════╣
    ║                                                                              ║
    ║  INSTRUCTIONS FOR USE:                                                       ║
    ║  ---------------------                                                       ║
    ║  1. HOW TO TEST LOCALLY:                                                     ║
    ║     - Simply open this HTML file in any modern browser (Chrome, Firefox,    ║
    ║       Safari, Edge). No server required for basic testing.                  ║
    ║     - Audio files are optional - the experiment works with placeholders.    ║
    ║                                                                              ║
    ║  2. AUDIO FILES (OPTIONAL):                                                  ║
    ║     - Place audio files (sentence1.mp3, sentence2.mp3, etc.) in the same   ║
    ║       directory as this HTML file.                                          ║
    ║     - Audio is set to play silently if files are missing (won't break).    ║
    ║                                                                              ║
    ║  3. HOW TO ADD MORE TRIALS:                                                  ║
    ║     - Find the 'timeline' array near the bottom of the script              ║
    ║     - Copy a trial object (trainingTrial or testTrial)                     ║
    ║     - Modify: shape, exitNumber, trialNumber, trialType, audioFile         ║
    ║     - Add to the timeline array                                             ║
    ║                                                                              ║
    ║  4. HOW TO MODIFY APPEARANCE:                                                ║
    ║     - Colors: See CONFIG object at top of script                           ║
    ║     - Sizes: See CONFIG object (hub radius, tube width, shape size)        ║
    ║     - Timing: See CONFIG.timing object (animation duration, ITI, etc.)     ║
    ║                                                                              ║
    ║  5. HOW TO CHANGE EXIT POSITIONS:                                            ║
    ║     - Modify CONFIG.exitAngles array (angles in degrees)                   ║
    ║     - 0° = right, 90° = down, 180° = left, -90° = up                       ║
    ║     - Exit positions are auto-calculated from angles                        ║
    ║                                                                              ║
    ║  EXPERIMENT DESIGN:                                                          ║
    ║  ------------------                                                          ║
    ║  - Radial apparatus with central hub and 6 radiating exit tubes            ║
    ║  - Training trials: Shape animates to exit, participant taps the shape     ║
    ║  - Test trials: Shape disappears mid-tube, participant guesses location    ║
    ║                                                                              ║
    ╚══════════════════════════════════════════════════════════════════════════════╝
    -->

    <!-- jsPsych 7.x CDN Links -->
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet">

    <style>
        /* Center the experiment content */
        .jspsych-content {
            max-width: 100%;
            padding: 0;
        }

        /* Canvas styling */
        #experiment-canvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
        }

        /* Instruction text styling */
        .instruction-text {
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #333;
            text-align: center;
            margin-top: 15px;
        }

        /* Results display */
        .results-container {
            font-family: monospace;
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            max-width: 700px;
            margin: 20px auto;
            text-align: left;
        }

        .results-container h2 {
            text-align: center;
            color: #333;
        }

        .results-container pre {
            background: #fff;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div id="jspsych-target"></div>

    <script>
    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * CONFIGURATION OBJECT
     * ═══════════════════════════════════════════════════════════════════════════
     *
     * All customizable parameters are centralized here for easy modification.
     * Change these values to adjust the experiment's appearance and behavior.
     */
    const CONFIG = {
        // Canvas dimensions
        canvas: {
            width: 800,
            height: 600
        },

        // Central hub (where shapes originate)
        hub: {
            x: 400,           // Center X position
            y: 300,           // Center Y position
            radius: 60,       // Hub circle radius
            color: '#CCCCCC'  // Light gray
        },

        // Exit tubes configuration
        tubes: {
            width: 45,            // Tube width in pixels
            length: 180,          // Distance from hub edge to exit point
            color: '#4CAF50',     // Green color for tubes
            exitMarkerRadius: 25  // Radius of circles at exit points
        },

        /**
         * EXIT ANGLES EXPLANATION:
         * -------------------------
         * Angles are measured in degrees from the positive X-axis (pointing right).
         * - 0° = right
         * - 90° = down (canvas Y increases downward)
         * - 180° or -180° = left
         * - -90° = up
         *
         * The 6 exits are arranged in a roughly hexagonal pattern around the hub.
         * We use these specific angles to create a balanced radial layout:
         */
        exitAngles: [
            -120,  // Exit 1: Upper-left
            -60,   // Exit 2: Upper-right
            180,   // Exit 3: Left (middle)
            0,     // Exit 4: Right (middle)
            120,   // Exit 5: Lower-left
            60     // Exit 6: Lower-right
        ],

        // Shape appearance
        shapes: {
            size: 35,                    // Shape size in pixels
            colors: {
                triangle: '#E74C3C',     // Red
                square: '#3498DB',       // Blue
                circle: '#F39C12',       // Orange
                diamond: '#9B59B6'       // Purple
            }
        },

        // Timing parameters (all in milliseconds)
        timing: {
            shapeAtHub: 1000,           // How long shape is visible at hub
            animation: 1000,             // Duration of shape animation
            pauseBeforePrompt: 500,      // Pause after shape disappears (test trials)
            feedbackDuration: 300,       // How long to show tap feedback
            iti: 500                     // Inter-trial interval (blank screen)
        }
    };


    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * CALCULATE EXIT POSITIONS
     * ═══════════════════════════════════════════════════════════════════════════
     *
     * MATHEMATICS OF RADIAL POSITIONING:
     * -----------------------------------
     * To place points around a circle, we use trigonometry:
     *
     *   x = centerX + radius * cos(angle)
     *   y = centerY + radius * sin(angle)
     *
     * Where:
     *   - centerX, centerY = hub center position
     *   - radius = distance from hub center to exit point (hub.radius + tubes.length)
     *   - angle = direction in radians (degrees * π/180)
     *
     * Note: In canvas coordinates, Y increases downward, so sin() gives the
     * expected results without needing to negate.
     *
     * Each exit endpoint is calculated by projecting outward from the hub center
     * at the specified angle, traveling a distance equal to hub radius + tube length.
     */
    function calculateExitPositions() {
        const positions = [];
        const totalRadius = CONFIG.hub.radius + CONFIG.tubes.length;

        for (let i = 0; i < CONFIG.exitAngles.length; i++) {
            // Convert degrees to radians (JavaScript's Math functions use radians)
            const angleRad = CONFIG.exitAngles[i] * (Math.PI / 180);

            // Calculate endpoint using polar-to-Cartesian conversion
            const x = CONFIG.hub.x + totalRadius * Math.cos(angleRad);
            const y = CONFIG.hub.y + totalRadius * Math.sin(angleRad);

            positions.push({
                exitNumber: i + 1,  // 1-indexed for human readability
                angle: CONFIG.exitAngles[i],
                angleRad: angleRad,
                x: Math.round(x),   // Round for cleaner coordinates
                y: Math.round(y)
            });
        }

        return positions;
    }

    // Pre-calculate all exit positions for use throughout the experiment
    const EXIT_POSITIONS = calculateExitPositions();

    // Log exit positions for debugging/verification
    console.log('Exit Positions:', EXIT_POSITIONS);


    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * DRAWING FUNCTIONS
     * ═══════════════════════════════════════════════════════════════════════════
     */

    /**
     * Draw the complete apparatus (hub, tubes, and exit markers)
     *
     * This function renders the entire experimental apparatus on the canvas.
     * It draws in layers: tubes first (so hub overlaps them cleanly), then
     * the hub, then exit markers on top.
     *
     * @param {CanvasRenderingContext2D} ctx - The canvas 2D rendering context
     * @param {boolean} showLabels - Whether to show exit numbers (for demo/debugging)
     */
    function drawApparatus(ctx, showLabels = true) {
        // Clear the entire canvas with white background
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);

        // STEP 1: Draw all 6 tubes
        // We draw tubes as thick lines from hub edge to exit point
        EXIT_POSITIONS.forEach((exit, index) => {
            // Calculate tube start point (at hub edge, not center)
            // This prevents tubes from overlapping in the hub center
            const startX = CONFIG.hub.x + CONFIG.hub.radius * Math.cos(exit.angleRad);
            const startY = CONFIG.hub.y + CONFIG.hub.radius * Math.sin(exit.angleRad);

            // Draw tube as a thick line
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(exit.x, exit.y);
            ctx.strokeStyle = CONFIG.tubes.color;
            ctx.lineWidth = CONFIG.tubes.width;
            ctx.lineCap = 'round';  // Rounded ends look nicer
            ctx.stroke();
        });

        // STEP 2: Draw the central hub (on top of tubes)
        ctx.beginPath();
        ctx.arc(CONFIG.hub.x, CONFIG.hub.y, CONFIG.hub.radius, 0, Math.PI * 2);
        ctx.fillStyle = CONFIG.hub.color;
        ctx.fill();
        ctx.strokeStyle = '#999999';  // Slightly darker border
        ctx.lineWidth = 3;
        ctx.stroke();

        // STEP 3: Draw exit markers (circles at each exit point)
        EXIT_POSITIONS.forEach((exit, index) => {
            // Exit marker circle
            ctx.beginPath();
            ctx.arc(exit.x, exit.y, CONFIG.tubes.exitMarkerRadius, 0, Math.PI * 2);
            ctx.fillStyle = darkenColor(CONFIG.tubes.color, 20);  // Slightly darker
            ctx.fill();
            ctx.strokeStyle = darkenColor(CONFIG.tubes.color, 40);
            ctx.lineWidth = 2;
            ctx.stroke();

            // Optional: Draw exit number labels
            if (showLabels) {
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(exit.exitNumber.toString(), exit.x, exit.y);
            }
        });
    }

    /**
     * Utility function to darken a hex color
     *
     * @param {string} color - Hex color string (e.g., '#4CAF50')
     * @param {number} percent - Amount to darken (0-100)
     * @returns {string} Darkened hex color
     */
    function darkenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, (num >> 16) - amt);
        const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
        const B = Math.max(0, (num & 0x0000FF) - amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
    }

    /**
     * Draw a shape at a specified position
     *
     * Supports multiple shape types: triangle, square, circle, diamond
     *
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {string} shapeType - Type of shape ('triangle', 'square', 'circle', 'diamond')
     * @param {number} x - Center X position
     * @param {number} y - Center Y position
     * @param {number} size - Shape size
     * @param {string} color - Fill color
     */
    function drawShape(ctx, shapeType, x, y, size, color) {
        ctx.fillStyle = color;
        ctx.strokeStyle = darkenColor(color, 30);
        ctx.lineWidth = 2;

        const halfSize = size / 2;

        switch (shapeType) {
            case 'triangle':
                // Equilateral triangle pointing up
                ctx.beginPath();
                ctx.moveTo(x, y - halfSize);                          // Top vertex
                ctx.lineTo(x - halfSize, y + halfSize * 0.6);         // Bottom-left
                ctx.lineTo(x + halfSize, y + halfSize * 0.6);         // Bottom-right
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                break;

            case 'square':
                // Simple square centered at (x, y)
                ctx.fillRect(x - halfSize, y - halfSize, size, size);
                ctx.strokeRect(x - halfSize, y - halfSize, size, size);
                break;

            case 'circle':
                ctx.beginPath();
                ctx.arc(x, y, halfSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                break;

            case 'diamond':
                // Diamond (rotated square)
                ctx.beginPath();
                ctx.moveTo(x, y - halfSize);      // Top
                ctx.lineTo(x + halfSize, y);      // Right
                ctx.lineTo(x, y + halfSize);      // Bottom
                ctx.lineTo(x - halfSize, y);      // Left
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                break;
        }
    }


    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * ANIMATION FUNCTION
     * ═══════════════════════════════════════════════════════════════════════════
     *
     * This function handles smooth shape animation from hub to exit.
     * Uses requestAnimationFrame for 60fps smooth animation.
     *
     * ANIMATION MATH:
     * ---------------
     * We use linear interpolation (lerp) to calculate intermediate positions:
     *   currentPos = startPos + progress * (endPos - startPos)
     *
     * Where progress goes from 0 to 1 over the animation duration.
     * For test trials, we stop at progress = 0.5 (midway through tube).
     *
     * @param {CanvasRenderingContext2D} ctx - Canvas context
     * @param {string} shape - Shape type to animate
     * @param {number} exitNumber - Which exit (1-6) to animate toward
     * @param {boolean} shouldComplete - If true, animate to exit; if false, disappear midway
     * @param {Function} onComplete - Callback when animation finishes
     */
    function animateShape(ctx, shape, exitNumber, shouldComplete, onComplete) {
        const exit = EXIT_POSITIONS[exitNumber - 1];  // Convert to 0-indexed
        const shapeColor = CONFIG.shapes.colors[shape] || '#E74C3C';

        // Animation parameters
        const startX = CONFIG.hub.x;
        const startY = CONFIG.hub.y;
        const endX = exit.x;
        const endY = exit.y;

        // For test trials, shape disappears at 50% progress (midway through tube)
        const maxProgress = shouldComplete ? 1.0 : 0.5;

        const startTime = performance.now();
        const duration = CONFIG.timing.animation;

        /**
         * Animation loop using requestAnimationFrame
         * This ensures smooth 60fps animation synced with display refresh
         */
        function animate(currentTime) {
            // Calculate progress (0 to 1)
            const elapsed = currentTime - startTime;
            let progress = elapsed / duration;

            // Clamp progress to maxProgress
            if (progress >= maxProgress) {
                progress = maxProgress;
            }

            // Calculate current position using linear interpolation
            const currentX = startX + progress * (endX - startX);
            const currentY = startY + progress * (endY - startY);

            // Redraw everything
            drawApparatus(ctx);

            // Draw shape at current position (if not past max progress)
            if (progress < maxProgress || shouldComplete) {
                drawShape(ctx, shape, currentX, currentY, CONFIG.shapes.size, shapeColor);
            }

            // Continue animation or finish
            if (progress < maxProgress) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete
                if (shouldComplete) {
                    // For training trials: shape stays at exit
                    // Redraw with shape at final position
                    drawApparatus(ctx);
                    drawShape(ctx, shape, endX, endY, CONFIG.shapes.size, shapeColor);
                }
                // Call completion callback
                if (onComplete) {
                    onComplete({
                        finalX: shouldComplete ? endX : currentX,
                        finalY: shouldComplete ? endY : currentY,
                        exitNumber: exitNumber
                    });
                }
            }
        }

        // Start the animation
        requestAnimationFrame(animate);
    }


    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * CLOSEST EXIT CALCULATION
     * ═══════════════════════════════════════════════════════════════════════════
     *
     * ALGORITHM EXPLANATION:
     * ----------------------
     * To find which exit is closest to a tap location, we:
     * 1. Calculate the Euclidean distance from tap to each exit point
     *    Distance = √[(x2-x1)² + (y2-y1)²]
     * 2. Return the exit number with the smallest distance
     *
     * This is used in test trials to determine if the participant correctly
     * predicted the shape's exit location.
     *
     * @param {number} tapX - X coordinate of tap
     * @param {number} tapY - Y coordinate of tap
     * @returns {Object} Object containing closest exit number and all distances
     */
    function calculateClosestExit(tapX, tapY) {
        let minDistance = Infinity;
        let closestExit = 1;
        const distances = {};

        EXIT_POSITIONS.forEach((exit) => {
            // Calculate Euclidean distance
            const dx = tapX - exit.x;
            const dy = tapY - exit.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            distances[exit.exitNumber] = Math.round(distance);

            if (distance < minDistance) {
                minDistance = distance;
                closestExit = exit.exitNumber;
            }
        });

        return {
            closestExit: closestExit,
            minDistance: Math.round(minDistance),
            allDistances: distances
        };
    }


    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * CUSTOM jsPsych PLUGIN FOR APPARATUS TRIALS
     * ═══════════════════════════════════════════════════════════════════════════
     *
     * We create a custom plugin to handle the unique requirements of our
     * apparatus trials (canvas animation, tap recording, etc.)
     */
    const apparatusTrialPlugin = {
        info: {
            name: 'apparatus-trial',
            parameters: {
                trial_number: {
                    type: 'INT',
                    default: 1
                },
                trial_type: {
                    type: 'STRING',
                    default: 'training'  // 'training' or 'test'
                },
                shape: {
                    type: 'STRING',
                    default: 'triangle'
                },
                exit_number: {
                    type: 'INT',
                    default: 1
                },
                audio_file: {
                    type: 'STRING',
                    default: null
                }
            }
        },

        trial: function(display_element, trial) {
            // Create container for canvas and instruction
            const container = document.createElement('div');
            container.style.textAlign = 'center';

            // Create canvas element
            const canvas = document.createElement('canvas');
            canvas.id = 'experiment-canvas';
            canvas.width = CONFIG.canvas.width;
            canvas.height = CONFIG.canvas.height;
            container.appendChild(canvas);

            // Create instruction text element
            const instruction = document.createElement('div');
            instruction.className = 'instruction-text';
            instruction.innerHTML = '&nbsp;';  // Placeholder to maintain spacing
            container.appendChild(instruction);

            display_element.appendChild(container);

            const ctx = canvas.getContext('2d');

            // Trial data that will be recorded
            const trialData = {
                trial_number: trial.trial_number,
                trial_type: trial.trial_type,
                shape: trial.shape,
                exit_number: trial.exit_number,
                intended_exit: trial.exit_number,
                tap_x: null,
                tap_y: null,
                tap_rt: null,
                closest_exit: null,
                tap_distances: null
            };

            // Timing variables
            let tapStartTime = null;
            let tapEnabled = false;
            let shapePosition = null;

            /**
             * Handle tap/click on canvas
             * Records coordinates and timing, then ends trial
             */
            function handleTap(event) {
                if (!tapEnabled) return;

                // Get tap coordinates relative to canvas
                const rect = canvas.getBoundingClientRect();
                const tapX = Math.round(event.clientX - rect.left);
                const tapY = Math.round(event.clientY - rect.top);

                // Calculate reaction time
                const tapRT = Math.round(performance.now() - tapStartTime);

                // Record tap data
                trialData.tap_x = tapX;
                trialData.tap_y = tapY;
                trialData.tap_rt = tapRT;

                // Calculate closest exit
                const exitCalc = calculateClosestExit(tapX, tapY);
                trialData.closest_exit = exitCalc.closestExit;
                trialData.tap_distances = exitCalc.allDistances;

                // Disable further taps
                tapEnabled = false;
                canvas.removeEventListener('click', handleTap);

                // Show feedback (training trials only)
                if (trial.trial_type === 'training') {
                    showFeedback(tapX, tapY);
                } else {
                    // Test trials: no feedback, end immediately
                    endTrial();
                }
            }

            /**
             * Show visual feedback at tap location (training trials)
             */
            function showFeedback(x, y) {
                // Draw a green checkmark/highlight
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, Math.PI * 2);
                ctx.strokeStyle = '#27AE60';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Show checkmark
                ctx.fillStyle = '#27AE60';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('✓', x, y - 35);

                // End trial after feedback duration
                setTimeout(endTrial, CONFIG.timing.feedbackDuration);
            }

            /**
             * End the trial and return data
             */
            function endTrial() {
                // Clear display
                display_element.innerHTML = '';

                // Log trial data to console for debugging
                console.log('Trial Data:', trialData);

                // End jsPsych trial
                jsPsych.finishTrial(trialData);
            }

            /**
             * Main trial sequence
             */
            function runTrial() {
                // Step 1: Draw apparatus
                drawApparatus(ctx);

                // Step 2: Show shape at hub center
                const shapeColor = CONFIG.shapes.colors[trial.shape] || '#E74C3C';
                drawShape(ctx, trial.shape, CONFIG.hub.x, CONFIG.hub.y, CONFIG.shapes.size, shapeColor);

                // Step 3: Play audio (if provided)
                if (trial.audio_file) {
                    try {
                        const audio = new Audio(trial.audio_file);
                        audio.volume = 0.5;
                        audio.play().catch(e => console.log('Audio not available:', e));
                    } catch (e) {
                        console.log('Audio playback error:', e);
                    }
                }

                // Step 4: Wait, then animate shape
                setTimeout(() => {
                    // Determine if shape completes journey
                    const shouldComplete = (trial.trial_type === 'training');

                    // Animate shape
                    animateShape(ctx, trial.shape, trial.exit_number, shouldComplete, (result) => {
                        shapePosition = result;

                        if (trial.trial_type === 'training') {
                            // Training: Shape is at exit, enable tap immediately
                            instruction.textContent = 'Tap the shape when you see it';
                            tapEnabled = true;
                            tapStartTime = performance.now();
                            canvas.addEventListener('click', handleTap);
                        } else {
                            // Test: Shape disappeared, show prompt after pause
                            setTimeout(() => {
                                // Redraw apparatus without shape
                                drawApparatus(ctx);

                                // Show instruction
                                instruction.textContent = 'Tap where you think the shape is';

                                // Enable tap
                                tapEnabled = true;
                                tapStartTime = performance.now();
                                canvas.addEventListener('click', handleTap);
                            }, CONFIG.timing.pauseBeforePrompt);
                        }
                    });
                }, CONFIG.timing.shapeAtHub);
            }

            // Start the trial
            runTrial();
        }
    };


    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * jsPsych INITIALIZATION AND TIMELINE
     * ═══════════════════════════════════════════════════════════════════════════
     */

    // Initialize jsPsych
    const jsPsych = initJsPsych({
        display_element: 'jspsych-target',
        on_finish: function() {
            // Get all trial data
            const allData = jsPsych.data.get().filter({trial_type_internal: 'apparatus-trial'}).values();

            // Display results on screen
            displayResults(allData);

            // Also log to console
            console.log('═══════════════════════════════════════════════');
            console.log('EXPERIMENT COMPLETE - ALL TRIAL DATA:');
            console.log('═══════════════════════════════════════════════');
            console.log(JSON.stringify(allData, null, 2));
        }
    });

    // Register our custom plugin
    jsPsych.pluginAPI.registerPlugin(apparatusTrialPlugin);

    /**
     * Display results at end of experiment
     */
    function displayResults(data) {
        const resultsHtml = `
            <div class="results-container">
                <h2>Experiment Complete!</h2>
                <p>Thank you for participating. Here is a summary of your responses:</p>

                <h3>Trial Data:</h3>
                <pre>${JSON.stringify(data, null, 2)}</pre>

                <h3>Summary:</h3>
                <ul>
                    ${data.map(trial => `
                        <li>
                            <strong>Trial ${trial.trial_number}</strong> (${trial.trial_type}):
                            ${trial.shape} → Exit ${trial.exit_number}<br>
                            Tapped at (${trial.tap_x}, ${trial.tap_y}) |
                            RT: ${trial.tap_rt}ms |
                            Closest exit: ${trial.closest_exit}
                        </li>
                    `).join('')}
                </ul>
            </div>
        `;
        document.getElementById('jspsych-target').innerHTML = resultsHtml;
    }


    /**
     * ═══════════════════════════════════════════════════════════════════════════
     * DEFINE TRIAL TIMELINE
     * ═══════════════════════════════════════════════════════════════════════════
     *
     * To add more trials:
     * 1. Copy one of the trial objects below
     * 2. Modify the parameters
     * 3. Add to the timeline array
     */

    // Welcome screen
    const welcomeTrial = {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
            <h1>Visual Rule Learning Experiment</h1>
            <p>In this experiment, you will see shapes moving through a multi-tube apparatus.</p>
            <p><strong>Training trials:</strong> Tap on shapes when they appear at exit points.</p>
            <p><strong>Test trials:</strong> Predict where shapes will appear by tapping.</p>
            <p>Click "Start" to begin.</p>
        `,
        choices: ['Start']
    };

    // ITI (Inter-Trial Interval) - blank screen between trials
    const itiTrial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '',
        trial_duration: CONFIG.timing.iti,
        choices: "NO_KEYS"
    };

    /**
     * TRIAL 1 - TRAINING TRIAL
     * ------------------------
     * Triangle shape animates from hub to Exit 1 (upper-left)
     * Participant taps the shape when it appears
     */
    const trainingTrial = {
        type: 'apparatus-trial',
        trial_number: 1,
        trial_type: 'training',
        shape: 'triangle',
        exit_number: 1,          // Exit 1: Upper-left
        audio_file: 'sentence1.mp3',
        data: {
            trial_type_internal: 'apparatus-trial'
        }
    };

    /**
     * TRIAL 2 - TEST TRIAL
     * --------------------
     * Square shape animates toward Exit 4 (right) but DISAPPEARS midway
     * Participant guesses where it would have appeared
     */
    const testTrial = {
        type: 'apparatus-trial',
        trial_number: 2,
        trial_type: 'test',
        shape: 'square',
        exit_number: 4,          // Exit 4: Right (intended)
        audio_file: 'sentence2.mp3',
        data: {
            trial_type_internal: 'apparatus-trial'
        }
    };

    /**
     * BUILD THE TIMELINE
     * ------------------
     * The timeline is an array of trial objects that jsPsych will execute in order.
     * To add more trials, simply add more trial objects to this array.
     *
     * Example of adding more trials:
     *
     * const trial3 = {
     *     type: 'apparatus-trial',
     *     trial_number: 3,
     *     trial_type: 'training',
     *     shape: 'circle',
     *     exit_number: 3,
     *     audio_file: 'sentence3.mp3',
     *     data: { trial_type_internal: 'apparatus-trial' }
     * };
     *
     * Then add to timeline: [..., itiTrial, trial3, ...]
     */
    const timeline = [
        welcomeTrial,
        trainingTrial,
        itiTrial,
        testTrial,
        itiTrial
    ];

    // Run the experiment!
    jsPsych.run(timeline);

    </script>
</body>
</html>
